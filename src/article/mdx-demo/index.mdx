---
title: "MDX"
short: "How I rewrote my gulp based static site generator to use mdx"
date: "2020-05-07"
type: "article"
---

import Test from './components/Test.jsx';
import Part from './components/part.mdx';

# MDX

Some time ago I felt an urge to write about pan-zoom components and how they can be made well. It's a type of component I like and I wanted to share the code and math that is needed to make pan and zoom behave well, both with a mouse and with touch screens. I ~~needed~~ wanted it to be an interactive article with demos and animations, but my website/blog was just a static site generated from markdown files using [gulp.js](https://gulpjs.com). I had seen the [very good article on reactjs](https://pomb.us/build-your-own-react/) by Rodrigo Pombo, where he used [Gatsby-waves](https://github.com/pomber/gatsby-waves) to have code update while the user scrolled, and I wanted to do something similar, but with math equations. So I gave [Gatsby](https://www.gatsbyjs.org/) a quick look and decided that I didn't really like it, too much GraphQL and to much magic just for a static site. But the wave stuff wasn't really using Gatsby, it was using something called [mdx](https://mdxjs.com/), which was jsx and markdown in the same file. This intrigued me, and I decided to look into having mdx support in my Gulpfile.

The basics of what I wanted is to convert an `index.mdx` file to `index.html` using gulp, like this:

```js
gulp.src('*.mdx')
  .pipe(mdx())
  .pipe(gulp.dest('out'));
```

The `mdx()` step is the interesting part here, taking in a stream of (potentially many) mdx files and producing a stream of html files that can be sent to the `out` directory. I couldn't find any `gulp-mdx` npm package, so I would have to write my own code. There was a short code example under [do it yourself](https://mdxjs.com/getting-started#do-it-yourself) on the website, and I decided to start from this one. It would convert `mdx` code first to `jsx` code then (using babel) to `js` code and then run the code to produce a react component which react could render as an `html` string. Quite a few steps. This is what my code looked like after a bit of tweaking:

```js
const babel = require('@babel/core');
const React = require('react');
const { renderToStaticMarkup } = require('react-dom/server');
const mdx = require('@mdx-js/mdx');
const { MDXProvider } = require('@mdx-js/react');

async function mdxToHtml(mdxCode, { mdxOptions, babelOptions, components }) {

  // mdx -> jsx
  const jsxCode = await mdx(mdxCode, mdxOptions);

  // jsx -> js
  const { code } = await babel.transformAsync("import { mdx } from '@mdx-js/react';\n" + jsxCode, babelOptions);

  // run the js code -> react component
  const layoutComponent = getDefaultExportFromModule(code, require);

  // component -> element
  const elementWithProvider = React.createElement(
    MDXProvider,
    { components },
    React.createElement(layoutComponent));

  // element -> html string
  return renderToStaticMarkup(elementWithProvider);
}
```

The first step is using the mdx compiler to convert mdx to jsx.

In the second step I add the line `import { mdx } from '@mdx-js/react'` before the `jsxCode`, since this is needed to convert jsx syntax (`<h1>title</h1>`) to js (`mdx('h1', null, 'hello')`). Here the `mdx` method replaces the more common `React.createElement` method that most jsx syntax get converted to.

The third step takes the js code and gets the js object that it exports. To do this a [function is created dynamically](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function). This is a bit like using `eval()`, and feels really hacky. But it works. The `require` parameter is needed so that other modules can be imported. Node still doesn't support ES6 modules very well, so babel has transpiled them into `require()` calls. Since the module code exports the component, rather than return it, we pick it out of the exports object like this:

```js
function getDefaultExportFromModule(code, require) {
  const exports = {};
  new Function('require', 'exports', code)(require, exports);
  return exports['default'];
}
```

This is enough code to convert an mdx file like this one

```md
# Does this work?

<h2 style={{background: 'red'}}>Test</h2>
```

into html:

```html
<h1>Does this work?</h1>

<h2 style="background: red">Test</h2>
```

It's not very exciting, but this simple test shows that both markdown and jsx get converted to html correctly. Great!

I then tried to import the `<h2>` from the file `Test.jsx`, to see if I could make and import more advanced react components, like this

```md
import Test from './Test.jsx';

# Does this work?

<Test />
```

But this failed with gulp giving the following error:

```
Error: Cannot find module './Test.jsx'
```

It seems `require` doesn't know to look for `Test.jsx` next to the `Index.mdx` file, so I need to tell it to do that. There is a very useful [`createRequire(path)`](https://nodejs.org/api/modules.html#modules_module_createrequire_filename) method exported by the `module` module, so I use it to create a new `require` method that can be passed to the `getDefaultExportFromModule`.

```js
const babel = require('@babel/core');
const React = require('react');
const { renderToStaticMarkup } = require('react-dom/server');
const mdx = require('@mdx-js/mdx');
const { MDXProvider } = require('@mdx-js/react');
const { createRequire } = require('module');

async function mdxToHtml(mdxCode, path, { mdxOptions, babelOptions, components }) {

  // mdx -> jsx
  const jsxCode = await mdx(mdxCode, mdxOptions);

  // jsx -> js
  const { code } = await babel.transformAsync("import { mdx } from '@mdx-js/react';\n" + jsxCode, babelOptions);

  // run the js code -> react component
  const require = createRequire(path);
  const layoutComponent = getDefaultExportFromModule(code, require);

  // component -> element
  const elementWithProvider = React.createElement(
    MDXProvider,
    { components },
    React.createElement(layoutComponent));

  // element -> html string
  return renderToStaticMarkup(elementWithProvider);
}
```

Now it runs, but fails with a different error (always a good sign that I'm heading in the right direction):

```
   <h2 style={{ background: 'red' }}>Test</h2>
    ^

SyntaxError: Invalid or unexpected token
```

It seems to fail because it's not able to understand the jsx syntax. The mdx source is transpiled, but whatever it imports isn't transpiled. So to fix this I needed to add some more features to the created `require` function. There is a deprecated but very useful and widely used feature of the `require` object, the [`require.extensions` array](https://nodejs.org/api/modules.html#modules_require_extensions). There are several warnings about not using it, but I went ahead and used it anyways.

```js
function createTranspilingRequire(path, babelOptions) {
  const require = createRequire(path);

  require.extensions['.jsx'] = (module, filename) => {
    const jsxCode = fs.readFileSync(filename, 'utf8');
    const { code } = babel.transformSync(jsxCode, babelOptions);
    module._compile(code, filename);
  };

  return require;
}
```

This function creates a new `require` function and then adds handling of `.jsx` files. A thing to note here is that it has to use the synchronous file loading and the synchronous babel transform since cjs and therefore node doesn't support async loading of modules. I have always found this weird, since the rest of node.js has been so proud of how everything is async and therefore can be run on a single thread. Except the module loading. Oh well.

With this in place I tried again, and now importing the jsx file worked! Great!

According to the mdx documentation it should also be possible to import mdx files, so I gave that a try too, and it failed again. To fix this I made a small change to the `createTranspilingRequire` so that it could transpile mdx files too:

```jsx

function createTranspilingRequire(path, mdxOptions, babelOptions) {
  const require = createRequire(path);

  require.extensions['.mdx'] = (module, filename) => {
    const mdxCode = fs.readFileSync(filename, 'utf8');
    const jsxCode = mdx.sync(mdxCode, { mdxOptions });
    const { code } = babel.transformSync("import { mdx } from '@mdx-js/react';\n" + jsxCode, babelOptions);
    module._compile(code, filename);
  };

  require.extensions['.jsx'] = (module, filename) => {
    const jsxCode = fs.readFileSync(filename, 'utf8');
    const { code } = babel.transformSync(jsxCode, babelOptions);
    module._compile(code, filename);
  };

  return require;
}
```

The added code is very similar to the `mdxToHtml` function, but now it is synchronous, not async.

There is just one small detail left to make this work with gulp, and that is how to call an async function per file in a stream. I looked online for some npm module that would work, but couldn't find any, so instead I wrote a small wrapper. This is really all you need:

```js
import { Transform } from 'stream';

export const mapAsync = func => new Transform({
  transform(chunk, _encoding, cb) {
    Promise.resolve(chunk)
      .then(func)
      .then(
        r => cb(null, r),
        e => cb(e, null));
  },
  objectMode: true
});

export const mapContentsAsync = func => mapAsync(async file => {
  const result = await func(file.contents.toString('utf8'), file);
  file.contents = Buffer.from(result);
  return file;
});
```

The second function uses the first function and makes it easier to work with gulp files, by converting between buffers and strings. I used the second function to wrap my `mdxToHtml` function like this:

```js

gulp.src('*.mdx')
  .pipe(mapContentsAsync(async (content, file) => {
    file.extname = '.html';
    return await mdxToHtml(content, file.path, { /*options*/ });
  }))
  .pipe(gulp.dest('out'));
```

And that's it, I now had a way to convert mdx files to html using gulp! ðŸ¥³

---

```js
console.log("example")
```

<Test />
<Part />
