---
title: "Webpack CSS LiveReload"
short: "Implementing a simple CSS live-reload plugin for webpack"
date: "2024-11-01"
type: "article"
---

## Webpack CSS LiveReload

In this article I will describe how to make a very simple but useful live-reload plugin for Webpack, since that is something I needed for a project. There are more complex plugins available, but they rely on the dev server which I couldn't use. Therefore I hacked together a simple plugin, and now I'm sharing my journey with you.

The goal is for the CSS in a website to automatically update whenever the source stylesheet is edited. To achive this we need to break the problem into smaller parts:

* Detect that a CSS file has changed
* Notify the website that depends on the CSS file
* Replace the existing CSS file with the new version

This should all be implemented as a webpack plugin. The simplest way to create a plugin in webpack, perfect for hacking together a quick test, is as a function:

```js
// webpack.config.js

module.exports = {
  entry: [ './src/index.js', './src/index.css'],
  output: {
    path: __dirname+'/output/assets',
    publicPath: '/assets/'
  },

  // Lots more configuration complicating things here...

  plugins: [
    (compiler) => {
      const plugin_name = 'live-reload';
      // This is now a simple plugin
      console.log("Look at me, I'm a plugin!");
    }
  ]
}
```

### Detecting changes to assets

Webpack plugins can be notified whenever an asset (any file generated by webpack) is emited (written to the filesystem) by subscribing to the [`assetEmitted` hook](https://webpack.js.org/api/compiler-hooks/#assetemitted), so let's set it up in the plugin.

```js
// webpack.config.js

module.exports = {
  entry: [ './src/index.js', './src/index.css'],
  output: {
    path: __dirname+'/output/assets',
    publicPath: '/assets/'
  },

  // Lots more configuration complicating things here...

  plugins: [
    (compiler) => {
      const plugin_name = 'live-reload';

      compiler.hooks.assetEmitted.tap(plugin_name, (name, info) => {
        console.log('emitted', name);
      });
    }
  ]
}
```

The name is relative to the `output.path` property, so a file like `/output/assets/main.css` will only have the name `main.css`. To get the path that the client is interested in, the one that is in `<link rel="stylesheet" href="/assets/main.css">`, we need to concat the `output.publicPath` property with the name.

```js
// webpack.config.js

module.exports = {
  entry: [ './src/index.js', './src/index.css'],
  output: {
    path: __dirname+'/output/assets',
    publicPath: '/assets/'
  },

  // Lots more configuration complicating things here...

  plugins: [
    (compiler) => {
      const plugin_name = 'live-reload';

      const publicPath = compiler.options.output.publicPath;

      compiler.hooks.assetEmitted.tap(plugin_name, (name, info) => {
        console.log('emitted', publicPath + name);
      });
    }
  ]
}
```

Note that publicPath can be a function, that is not handled here.

### Notifying the client

Now that we know if a file has changed we need to notify the client. I'm going to use [Server Sent Events](https://web.dev/articles/eventsource-basics) to do this, because it's very simple to set up yet robust. This requires a small client side script that can connect to a small webserver and listen for events. The events are sent to the client as newline separated text, something like this:

```
event: message
data: Something here

event: message
data: Data is always a string

event: message
data: {"json": true, "text": "To send something more complex just serialize it as JSON"}
```

In the above example you can see that each event is separated by two newline characters, and each event has a name (`message` in the above example) and some data. There are some more options and technical details, but this is enough for us to implement a live-reload server.

Webpack runs in node.js so we can make a simple node http server that only sends messages like this:

```js
import http from 'http';

function createSseServer(port = 8789) {
  const server = http.createServer((req, res) => {
    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Access-Control-Allow-Origin': '*',
      Connection: 'keep-alive',
    });

    req.on('close', () => {
      res.end();
    });

    res.write('event: open\n\n');

    res.write('event: message\n');
    res.write('data: Hello\n\n');
  });

  server.listen(port);
}
```

That's it, this little server will send two messages and then do nothing. Creating a client that listens to these events is even simpler:

```js
// client.js

const es = new EventSource('http://localhost:8789', { withCredentials: false });

es.addEventListener('open', () => {
  console.info('Connected to live-reload server');
});

es.addEventListener('error', () => {
  console.warn('Disconnected from live-reload server');
});

es.addEventListener('message', ev => {
  console.log(ev.data); // this will log Hello
});
```

We want to send an event every time a file changes, so let's expand on the server a bit

```js
import EventEmitter from 'events';
import http from 'http';

function createSseServer(port = 8789) {
  const events = new EventEmitter();

  const server = http.createServer((req, res) => {
    const listener = (data) => res.write(data);

    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Access-Control-Allow-Origin': '*',
      Connection: 'keep-alive',
    });

    req.on('close', () => {
      res.end();
      events.off('message', listener);
    });

    res.write('event: open\n\n');

    events.on('message', listener);
  });

  server.listen(port);

  return {
    sendMessage(data){
      events.emit('message', `event: message\ndata: ${JSON.stringify(data)}\n\n`);
    }
  }
}
```

I've expanded the server with an EventEmitter and made the function return an object with a `sendMessage` function. The data parameter is serialized as json and sent to the client. We can now use this in our plugin to send messages to the client:


```js
// webpack.config.js

module.exports = {
  entry: [ './src/index.js', './src/index.css'],
  output: {
    path: __dirname+'/output/assets',
    publicPath: '/assets/'
  },

  // Lots more configuration complicating things here...

  plugins: [
    (compiler) => {
      const plugin_name = 'live-reload';

      const sseServer = createSseServer();

      const publicPath = compiler.options.output.publicPath;

      compiler.hooks.assetEmitted.tap(plugin_name, (name, info) => {
        sseServer.sendMessage({ asset: publicPath + name });
      });
    }
  ]
}
```

Now we just need the client code to react to these messages.

### Updating the CSS in the client

The client gets a message every time any asset changes, but so far it only `console.logs` it. We can filter it so it only reacts to css files (maybe this should have been done in the server?).

```js
// client.js

const es = new EventSource('http://localhost:8789', { withCredentials: false });

es.addEventListener('open', () => {
  console.info('Connected to live-reload server');
});

es.addEventListener('error', () => {
  console.warn('Disconnected from live-reload server');
});

es.addEventListener('message', ev => {
  const { asset } = JSON.parse(ev.data);
  // We only care about css files
  if (typeof asset !== 'string') return;
  if (!asset.endsWith('.css')) return;
  const stylesheet = Array.from(document.styleSheets)
    .filter(s => s.href)
    .find(s => new URL(s.href).pathname === asset);
  if (!stylesheet) return;
  const link = stylesheet.ownerNode;
  const clone = link.cloneNode();
  clone.setAttribute('href', asset + '?' + Date.now());
  link.insertAdjacentElement('afterend', clone);
  clone.addEventListener('load', () => link.remove());
});
```

Next we want to update the stylesheet that has changed. We can look at all the stylesheets in the document using [`document.stylesheets`](https://developer.mozilla.org/en-US/docs/Web/API/Document/styleSheets) and compare their [`href`](https://developer.mozilla.org/en-US/docs/Web/API/StyleSheet/href) with the `asset` value. We can then use [`ownerNode`](https://developer.mozilla.org/en-US/docs/Web/API/StyleSheet/ownerNode) to find the `<link rel="stylesheet" href="...">` that imported it. This is slightly limiting in that it cannot replace `@import url('./another.css')` stylesheets.

To replace the code I clone the `<link>` and then remove the old one when the clone has loaded. This way there will not be a flash of unstyled content ([https://en.wikipedia.org/wiki/Flash_of_unstyled_content](FOUC)). The cloned link get's the current time in milliseconds appended at the end to bypass the cache.

And that's about it, we have a simple but working live-reload implementation.

### Getting the client code into the bundle

There are a few details I have skipped over so far to keep things simple. For example, we only want this plugin during `watch`. That is simple enough to do.


```js
// webpack.config.js

module.exports = {
  entry: [ './src/index.js', './src/index.css'],
  output: {
    path: __dirname+'/output/assets',
    publicPath: '/assets/'
  },

  // Lots more configuration complicating things here...

  plugins: [
    (compiler) => {
      const plugin_name = 'live-reload';

      if (!compiler.options.watch) return;

      const sseServer = createSseServer();

      const publicPath = compiler.options.output.publicPath;

      compiler.hooks.assetEmitted.tap(plugin_name, (name, info) => {
        sseServer.sendMessage({ asset: publicPath + name });
      });
    }
  ]
}
```

But we also want to add the client code to our entry bundle. This is also quite easy to do, although the webpack documentation doesn't want to admit that.

```js
// webpack.config.js

module.exports = {
  entry: [ './src/index.js', './src/index.css'],
  output: {
    path: __dirname+'/output/assets',
    publicPath: '/assets/'
  },

  // Lots more configuration complicating things here...

  plugins: [
    (compiler) => {
      const plugin_name = 'live-reload';

      if (!compiler.options.watch) return;

      compiler.options.entry['main'].import?.push(require.resolve('./client.js'));

      const sseServer = createSseServer();

      const publicPath = compiler.options.output.publicPath;

      compiler.hooks.assetEmitted.tap(plugin_name, (name, info) => {
        sseServer.sendMessage({ asset: publicPath + name });
      });
    }
  ]
}
```

I'm assuming you want to add it to the main entry, but we could pull this plugin out as a class so that we can provide some options to it:

```js
// live-reload-plugin.js
module.exports = class LiveReloadPlugin {
  constructor ({entry = 'main'} = {}){
    this.options = {entry};
  }

  apply(compiler) {
    const plugin_name = 'live-reload';

    if (!compiler.options.watch) return;

    compiler.options.entry[this.options.entry].import?.push(require.resolve('./client.js'));

    const sseServer = createSseServer();

    const publicPath = compiler.options.output.publicPath;

    compiler.hooks.assetEmitted.tap(plugin_name, (name, info) => {
      sseServer.sendMessage({ asset: publicPath + name });
    });
  }
}
```

Now we can create a new instance of this plugin in the webpack config file


```js
// webpack.config.js

module.exports = {
  entry: [ './src/index.js', './src/index.css'],
  output: {
    path: __dirname+'/output/assets',
    publicPath: '/assets/'
  },

  // Lots more configuration complicating things here...

  plugins: [
    new LiveReloadPlugin({
      entry: 'main',
      port: 9876
    })
  ]
}
```

This way we can supply other options, for example the port we want the SSE server to run on, lie I've done above. The plugin class takes this option too, and then we use the [DefinePlugin](https://webpack.js.org/plugins/define-plugin/) to define it for the client code.

```js

// live-reload-plugin.js
module.exports = class LiveReloadPlugin {
  constructor ({entry = 'main', port: 8789} = {}){
    this.options = {entry, port};
  }

  apply(compiler) {
    const plugin_name = 'live-reload';

    if (!compiler.options.watch) return;

    new DefinePlugin({
        ___LIVE_RELOAD_PORT___: this.options.port,
    }).apply(compiler);


    compiler.options.entry[this.options.entry].import?.push(require.resolve('./client.js'));

    const sseServer = createSseServer();

    const publicPath = compiler.options.output.publicPath;

    compiler.hooks.assetEmitted.tap(plugin_name, (name, info) => {
      sseServer.sendMessage({ asset: publicPath + name });
    });
  }
}
```

The client code is updated with this magic variable which will be replaced by the DefinePlugin.

```js
// client.js
const url = new URL(document.location);
url.port = ___LIVE_RELOAD_PORT___;
const es = new EventSource(url, { withCredentials: false });

es.addEventListener('open', () => {
  console.info('Connected to live-reload server');
});

es.addEventListener('error', () => {
  console.warn('Disconnected from live-reload server');
});

es.addEventListener('message', ev => {
  const { asset } = JSON.parse(ev.data);
  // We only care about css files
  if (typeof asset !== 'string') return;
  if (!asset.endsWith('.css')) return;
  const stylesheet = Array.from(document.styleSheets)
    .filter(s => s.href)
    .find(s => new URL(s.href).pathname === asset);
  if (!stylesheet) return;
  const link = stylesheet.ownerNode;
  const clone = link.cloneNode();
  clone.setAttribute('href', asset + '?' + Date.now());
  link.insertAdjacentElement('afterend', clone);
  clone.addEventListener('load', () => link.remove());
});
```

And that's about it! There are improvements that can be done, obviously, but this seems to be working well enough for me now.